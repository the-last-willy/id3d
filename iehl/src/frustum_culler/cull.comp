#version 450 core

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Common modules.

////////////////////////////////////////////////////////////////////////////////
// Bounds.

// Invariants:
// 'b[0] <= b[1]'.
struct Bounds {
    // 'b[0]' is the lower bound.
    // 'b[1]' is the upper bound.
    // 'b[0][3]' and 'b[1][3]' are expected to be '1.'
    // and are inteded for paddind reasons.
    vec4 b[2];
};

Bounds to_bounds(in vec4 point) {
    Bounds bs;
    bs.b[0] = point;
    bs.b[1] = point;
    return bs;
}

bool are_separated(in Bounds bs0, in Bounds bs1) {
    bool b0 = any(greaterThan(bs0.b[0].xyz, bs1.b[1].xyz));
    bool b1 = any(   lessThan(bs0.b[1].xyz, bs1.b[0].xyz));
    return b0 || b1;
}

void extend(inout Bounds bs, in vec3 v) {
    bs.b[0].xyz = min(bs.b[0].xyz, v);
    bs.b[1].xyz = max(bs.b[1].xyz, v);
    // for(int i = 0; i < 3; ++i) {
    //     if(v[i] < bs.b[0][i]) {
    //         bs.b[0][i] = v[i];
    //     } else if(v[i] > bs.b[1][i]) {
    //         bs.b[1][i] = v[i];
    //     }
    // }
}

Bounds bounds_transformed(in Bounds bs, in mat4 transform) {
    Bounds transformed;
    vec3[8] corners = vec3[8](
        vec3(bs.b[0].x, bs.b[0].y, bs.b[0].z),
        vec3(bs.b[0].x, bs.b[0].y, bs.b[1].z),
        vec3(bs.b[0].x, bs.b[1].y, bs.b[0].z),
        vec3(bs.b[0].x, bs.b[1].y, bs.b[1].z),
        vec3(bs.b[1].x, bs.b[0].y, bs.b[0].z),
        vec3(bs.b[1].x, bs.b[0].y, bs.b[1].z),
        vec3(bs.b[1].x, bs.b[1].y, bs.b[0].z),
        vec3(bs.b[1].x, bs.b[1].y, bs.b[1].z));
    // First corner.
    {
        vec4 corner = vec4(corners[0], 1.);
        vec4 transformed_corner = transform * corner;
        transformed = to_bounds(transformed_corner / transformed_corner.w);
    }
    // Remaining corners.
    for(int i = 1; i < 8; ++i) {
        vec4 corner = vec4(corners[i], 1.);
        vec4 transformed_corner = transform * corner;
        extend(transformed, transformed_corner.xyz / transformed_corner.w);
    }
    return transformed;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// IO modules.

////////////////////////////////////////////////////////////////////////////////
// Coordinate systems.

uniform mat4 world_to_clip;

// 'clip_to_world' is not necessary
// as the frustum is precomputed in world space.

////////////////////////////////////////////////////////////////////////////////
// Draw command.

// 'glDrawElementsIndirectCommand'.
struct DrawCommand {
    uint  count;
    uint  instanceCount;
    uint  firstIndex;
    uint  baseVertex;
    uint  baseInstance;
};

////////////////////////////////////////////////////////////////////////////////
// Draw command / input.

layout(std430) readonly
buffer input_draw_commands_buffer {
    DrawCommand input_draw_commands[/*draw id*/];
};

////////////////////////////////////////////////////////////////////////////////
// Draw command / output.

layout(std430) coherent
buffer output_draw_command_count_buffer {
    uint output_draw_command_count;
};

layout(std430) writeonly
buffer output_draw_commands_buffer {
    DrawCommand output_draw_commands[/*draw id*/];
};

////////////////////////////////////////////////////////////////////////////////
// Frustum.

uniform Bounds frustum_clip_bounds;
uniform Bounds frustum_world_bounds;

////////////////////////////////////////////////////////////////////////////////
// Object / group.

layout(std430) readonly
buffer object_world_bounds_buffer {
    Bounds object_world_bounds[/*instance id*/];
};

// Might want to precompute object clip bounds in a previous pass
// since they will be reused in other compute shaders ?
// That would be less logic here as well.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

shared uint local_accepted_count;
shared uint local_offset;

layout(local_size_x = 256) in;

void main() {
    uint global_id = gl_GlobalInvocationID.x;
    uint local_id = gl_LocalInvocationID.x;

    if(local_id == 0) {
        local_accepted_count = 0;
    }

    barrier();

    DrawCommand draw_command;
    bool accepted = false;

    if(global_id < input_draw_commands.length()) {
        draw_command = input_draw_commands[global_id];

        Bounds object_world_bs = object_world_bounds[draw_command.baseInstance];
        Bounds object_clip_bs = bounds_transformed(object_world_bs, world_to_clip);

        accepted = false;
        accepted = accepted || are_separated(object_clip_bs, frustum_clip_bounds);
        accepted = accepted || are_separated(object_world_bs, frustum_world_bounds);

        accepted = !accepted;
        
        if(accepted) {
            atomicAdd(local_accepted_count, 1);
        }
    }

    barrier();

    // 'readFirstInvocationARB' would be better here.
    if(local_id == 0) {
        local_offset = atomicAdd(output_draw_command_count, local_accepted_count);
    }

    barrier();

    if(accepted) {
        uint offset = atomicAdd(local_offset, 1);
        output_draw_commands[offset] = draw_command;
    }
}
