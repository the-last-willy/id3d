#version 450 core

struct DrawParameters {
    uint count;
    uint instance_count;
    uint first_index;
    uint base_vertex;
    uint base_instance;
};

struct Interval {
    vec4 lb;
    vec4 ub;
};

layout(location = 0) uniform Interval frustum_clip_bounds;
layout(location = 2) uniform Interval frustum_world_bounds;
layout(location = 4) uniform mat4 world_to_clip;

layout(std430, binding = 0) readonly buffer objects_bounds_buffer {
    Interval objects_bounds[];
};

layout(std430, binding = 1) readonly buffer input_draw_parameters_buffer {
    DrawParameters input_draw_parameters[];
};

layout(std430, binding = 2) coherent buffer output_count_buffer {
    uint output_count;
};

layout(std430, binding = 3) writeonly buffer output_draw_parameters_buffer {
    DrawParameters output_draw_parameters[];
};

bool is_frustum_culled_in_clip_space(in Interval object_world_bounds) {
    // Compute object bounds in clip space.
    Interval object_clip_bounds;
    // Computes all corners.
    vec4 corners[8] = vec4[8](
        vec4(object_world_bounds.lb[0], object_world_bounds.lb[1], object_world_bounds.lb[2], 1.f),
        vec4(object_world_bounds.lb[0], object_world_bounds.lb[1], object_world_bounds.ub[2], 1.f),
        vec4(object_world_bounds.lb[0], object_world_bounds.ub[1], object_world_bounds.lb[2], 1.f),
        vec4(object_world_bounds.lb[0], object_world_bounds.ub[1], object_world_bounds.ub[2], 1.f),
        vec4(object_world_bounds.ub[0], object_world_bounds.lb[1], object_world_bounds.lb[2], 1.f),
        vec4(object_world_bounds.ub[0], object_world_bounds.lb[1], object_world_bounds.ub[2], 1.f),
        vec4(object_world_bounds.ub[0], object_world_bounds.ub[1], object_world_bounds.lb[2], 1.f),
        vec4(object_world_bounds.ub[0], object_world_bounds.ub[1], object_world_bounds.ub[2], 1.f));
    // Initialize interval with first corner.
    object_clip_bounds.lb = world_to_clip * corners[0];
    object_clip_bounds.lb /= object_clip_bounds.lb[3];
    object_clip_bounds.ub = object_clip_bounds.lb;
    // Extend interval to include all corners.
    for(uint i = 1; i < 8; ++i) {
        vec4 transformed = world_to_clip * corners[i];
        transformed /= transformed[3];
        object_clip_bounds.lb = min(object_clip_bounds.lb, transformed);
        object_clip_bounds.ub = max(object_clip_bounds.ub, transformed);
    }
    return false
    || any(greaterThan(
        object_clip_bounds.lb.xyz,
        frustum_clip_bounds.ub.xyz))
    || any(lessThan(
        object_clip_bounds.ub.xyz,
        frustum_clip_bounds.lb.xyz));
}

bool is_frustum_culled_in_world_space(in Interval object_world_bounds) {
    return false
    || any(greaterThan(
        object_world_bounds.lb,
        frustum_world_bounds.ub))
    || any(lessThan(
        object_world_bounds.ub,
        frustum_world_bounds.lb));
}

bool is_frustum_culled(in Interval object_world_bounds) {
    return false
    || is_frustum_culled_in_clip_space(
        object_world_bounds)
    || is_frustum_culled_in_world_space(
        object_world_bounds);
}

// shared uint output_index;

layout(local_size_x = 256) in;

void main() {
    uint index = gl_GlobalInvocationID.x;
    if(index < objects_bounds.length()) {
        if(!is_frustum_culled(objects_bounds[index])) {
            uint output_index = atomicAdd(output_count, 1);
            output_draw_parameters[output_index] = input_draw_parameters[index];
        }
    }
}
